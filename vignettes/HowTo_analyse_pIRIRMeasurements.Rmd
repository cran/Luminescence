---
title: "How to analyse post-IR IRSL measurements?"
author: "Sebastian Kreutzer, IRAMAT-CRP2A, UMR 5060, CNRS - UniversitÃ© Bordeaux Montagine, France"
date: "Last modified: `r Sys.Date()` ('Luminescence' version: `r packageVersion('Luminescence')`)"
output: 
  rmarkdown::html_vignette:
    fig_caption: yes
    number_sections: yes
    toc: yes
bibliography: Tutorial_Analysing_pIRIR_protocol.bib
vignette: >
  %\VignetteEncoding{UTF-8}
---
# Scope and introduction

Using the function `analyse_SAR.CWOSL()` are `Analyse_SAR.OSLdata()` from the 
**R** package 'Luminescence' allows to analyse standard OSL (quartz) measurements
based on the SAR protocol [@Murray_2000cr]. 

The function `analyse_SAR.CWOSL()` can also be used for analysing measurements based on the post-IR IRSL 
protocol (pIRIR, @Thomsen_2008qv), since the measurement
protocol based on the SAR structure (see the following table) 
comprising a set of curves with a $L_{x}$ and $T_{x}$ signal pattern. 

Step          | Example     | Signal    |
--------------|-------------|-----------|
Irradiation   | beta-irr.   | -         |
Heating       | preheat/TL  | -         |
Stimulation   | OSL         | $L_x$     |
Irradiation   | beta-irr.   |-          |
Heating       | cutheat/TL  | -         |
Stimulation   | OSL         | $T_x$     |

To lower the entry level and make the analysis of post-IR IRSL data more straightforward, some time ago, 
the function `analyse_pIRIRSequence()` was developed. This function is basically a wrapper around the two functions `analyse_SAR.CWOSL()` and `plot_GrowthCurve()`. 

This vignette provides a short tutorial exemplifying the analysis of post-IR IRSL data in **R**. 
To avoid misunderstandings, please keep in mind that the post-IR IRSL protocol is a simple
extension of the SAR structure by introducing further stimulations steps only:

Step          | Example     | Signal    |
--------------|-------------|-----------|
Irradiation   | beta-irr.   | -         |
Heating       | preheat/TL  | -         |
Stimulation   | IR$_{50}$   |   $L_{x_{_1}}$ |
Stimulation   | pIRIR$_{225}$   |   $L_{x_{_2}}$ |
Irradiation   | beta-irr.   |-          |
Heating       | preheat/TL  | -         |
Stimulation   | IR$_{50}$   |   $T_{x_{_1}}$ |
Stimulation   | pIRIR$_{225}$   |   $T_{x_{_2}}$ |

While the number of IRSL stimulation steps is not limited in general (cf. @Fu:2012ca), the number of steps 
used for recording the signal of interest and the test dose signal must be equal.
Example, if the sequence has two stimulation steps for the signal ($L_{x_{_1}}$, $L_{x_{_2}}$) 
(as in the table given above), it also needs two stimulations steps for measuring the test dose. 
Further steps, e.g., hot bleach steps at the end of the cycle, are allowed, but **do not** belong 
to the SAR structure and should be removed prior any analysis using the function `analyse_pIRIRSequence()`.

*Note: The terminal and graphical output show below is partly truncated to shorten the length of this vignette, however, calling the functions in R will show the full output.*

# Running example

In our example, the measurement was carried out on a Freiberg Instruments lexsyg luminescence
reader. Measurement data are stored in XML-based file format called
*XSYG*. Two pIRIR signals were measured: A IR$_{50}$ and a pIRIR$_{225}$ signal.
The preheat steps were carried out as TL.

## Data import

To start with, the package 'Luminescence' itself has to be loaded. In a next step, 
measurement data are imported using the function `read_XSYG2R()`. If your input format is a BIN/BINX-file, 
replace the function `read_XSYG2R()` by `read_BIN2R()`.

```{r,echo=TRUE, message=FALSE, R.options=list(width = 10)}
library(Luminescence)
temp <-  read_XSYG2R("pIRIR_measurementData.xsyg", fastForward = TRUE, txtProgressBar = FALSE)
```

To se the dataset in the **R** terminal, just call the object `temp`

```{r, eval = FALSE}
temp
```
```{r, echo = FALSE}
cat(paste(c(capture.output(temp)[1:15], "... <remaining records truncated manually>"), collapse = "\n"))
```

The output shows an `RLum.Analysis` object, which contains all recorded curves (`RLum.Data.Curve` objects) 
from one aliquot (e.g., cup/disc). In total, the dataset contains the curves of `r length(temp)` aliquots. All records are numbered, here from `#1` to `#208` (shown only until `#29`) and named by their corresponding record type (`TL`, `IRSL`). So far available, within round brackets, information on the detector are given (`UVVIS` and `NA`). This reveals that the object contains curves which are not wanted for the analysis. 

Curves which belong to a specific measurement step (e.g., IRSL stimulation) are connected with the `<>` symbol. 
However, curves with `(NA)` are curves recorded by technical components (e.g., temperature sensor) other than the photomultiplier tube and not wanted, even they belong to the dataset. In our case, unfortunately, the information `(UVVIS)` is rather uninformative, but a usual case, since *it depends on the measurement device whether information on the detector are available or not.* This example emphasises that prior knowledge of the data structure and the used technical components are indispensable.

## Select wanted curves

To select only wanted curves wanted for the analysis the function `get_RLum()` can be used: 

```{r}
temp_sel <- get_RLum(temp, recordType = "UVVIS", drop = FALSE)
```

```{r, eval = FALSE}
temp_sel
```
```{r, echo = FALSE}
cat(paste(c(capture.output(temp_sel)[1:10], "... <remaining records truncated manually>"), collapse = "\n"))
```

The function `get_RLum()` is very powerful and supports sophisticated subsetting of a `RLum.Analysis` objects.
Further useful arguments are `curveType` and `record.id`. The latter one allows a subsetting by record
id (e.g., `record.id = 2` to select `#2`) and supports also negative subsetting (e.g., to remove only `#2`, type 
`record.id = -2`). To understand the meaning of the argument `drop = FALSE`, please call the function `get_RLum()` 
another time with `drop = TRUE` and see the difference in the **R** terminal. 
For all supported arguments see the  manual of the function by typing `?get_RLum` in the **R** terminal. 

In our example, however, the dataset does not yet follow the SAR structure. The sequence comprises a
hotbleach at the end of each cycles (record `#7` in the terminal output example above). This curves are not 
wanted a have to be removed. This can be done using again the function `get_RLum()` with the argument 
`record.id`. Please note that by executing the following example the object `temp_sel` will be replaced. 

```{r}
temp_sel <- get_RLum(temp_sel, record.id = -seq(7,length(temp_sel[[1]]), by = 7), drop = FALSE)
```
```{r, eval = FALSE}
temp_sel
```
```{r, echo = FALSE}
cat(paste(c(capture.output(temp_sel)[1:10], "... <remaining records truncated manually>"), collapse = "\n"))
```

Using a negative subsetting, all hotbleach curves have been removed using the call 
`-seq(7,length(temp_sel[[1]]), by = 7)`. Important is to understand that the function `length()` 
was called for the first list element of `temp_sel`, which contains the recorded curves for the first 
aliquot only. To see the differences type: 

```{r}
length(temp_sel)
length(temp_sel[[1]])
```

In other words, our measurement record has data from `r length(temp_sel)` aliquots and each aliquot
consits of (at least) `r length(temp_sel[[1]])` records. We here further assume that the number
of records is similar for each aliquot. 

# Analyse sequence 

Now the object `temp_sel` only comprises TL and IRSL curves, and this data can be directly 
passed to the function `analyse_pIRIRSequence()`:

```{r, echo=FALSE, eval = FALSE}
results <- analyse_pIRIRSequence(
  object = temp_sel,
  signal.integral.min = 1,
  signal.integral.max = 10,
  background.integral.min = 800, 
  background.integral.max = 999,
  dose.points = c(0, 340, 680, 1020, 1360, 0, 340))
```

```{r, fig.height=14, fig.width=14, out.height="400px", out.height="400px", fig.align="center", dpi=50}
results <- analyse_pIRIRSequence(
  object = temp_sel[[1]],
  signal.integral.min = 1,
  signal.integral.max = 10,
  background.integral.min = 800, 
  background.integral.max = 999,
  dose.points = c(0, 340, 680, 1020, 1360, 0, 340),
  verbose = FALSE)
```

```{r, echo=FALSE, eval = TRUE}
results <- analyse_pIRIRSequence(
  object = temp_sel,
  signal.integral.min = 1,
  signal.integral.max = 10,
  background.integral.min = 800, 
  background.integral.max = 999,
  dose.points = c(0, 340, 680, 1020, 1360, 0, 340), 
  verbose = FALSE, 
  plot = FALSE)
```

The function expects the setting of some arguments, for details and meaning, please see `?analyse_pIRIRSequence`. 
If the imported measurement data do not carry information on the `dose.points`, as it is the case in our example, these
values have to be provided manually. Please note that the information needed for `dose.points` is something 
which was defined while writing the measurement sequence (your irradiation times).

The function output is a comprehensive plot scheme and a so-called `RLum.Results` object, which contains
all relevant calculations from the analysis. 

```{r}
results
```

The $D_{e}$ values (here in seconds) can be seen by calling the `$data` element from the object `results`, 
which is a `data.frame` (and here limited to three columns):

```{r}
results$data[,c("De", "De.Error", "RC.Status", "Signal")]
```

The column `RC.Status` informs you about a failed rejection criterium, which one is not revealed, 
but the column provides a possibilty for further subsetting. For a quick data processing this is, 
together with the plot output, usually enough information. However, to see all rejection criteria 
type `results$rejection.criteria`. To see all information type `results$data` without further information. 

If you want to combine the two tables for a more virtous data processing, you can merge both tables
by calling:

```{r}
df <- merge(results$data, results$rejection.criteria, by = "UID")
head(df)
```

The result may appear confusing in a first instance, since, e.g. the column `De` appears to contain duplicated
entries. But still, each row is unique and in sum contains unique information. 

# Plot results

To plot the `pIRIR225` $D_{e}$ values the following call can be used: 

```{r, fig.align="center", fig.width=4, fig.height=4, dpi=50}
plot_KDE(
  data = subset(results$data, Signal == "pIRIR225")[, c("De", "De.Error")],
  xlab = expression(paste(D[e], " [s]")), 
  summary = c("n", "mean", "sd.abs")
  )
```

# Compacted call

The above-listed steps can also be shortened to a concise **R** call using the so-called `magriitr` operator, 
which basically pipes the results from function to function. To have a difference the final 
plot is an Abanico plot @Dietze:2015dp. 

*Please note that for this last example the arguments `plot` and `verbose` have been set to 
`FALSE` for most of the functions.*

```{r, eval = TRUE, warning=FALSE, fig.align="center", fig.width=5, fig.height=5, dpi=50}
results <- read_XSYG2R("pIRIR_measurementData.xsyg", fastForward = TRUE, verbose = FALSE) %>%
  get_RLum(recordType = "UVVIS", drop = FALSE) %>%
  get_RLum(.,record.id = -seq(7,length(.[[1]]), by = 7), drop = FALSE) %>%
  analyse_pIRIRSequence(
    signal.integral.min = 1,
    signal.integral.max = 10,
    background.integral.min = 800, 
    background.integral.max = 999,
    dose.points = c(0, 340, 680, 1020, 1360, 0, 340), 
    verbose = FALSE, 
    plot = FALSE) %>%
  get_RLum() %>%
  subset(.,subset = Signal == "pIRIR225") %>%
  plot_AbanicoPlot(
  data = .[, c("De", "De.Error")],
  zlab = expression(paste(D[e], " [s]")), 
  summary = c("n", "mean", "sd.abs")
  )
```

#References {-}
